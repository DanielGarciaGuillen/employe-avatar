{"ast":null,"code":"//////////////////////////////////////////\n// Needle -- Node.js HTTP Client\n// Written by Tom√°s Pollak <tomas@forkhq.com>\n// (c) 2012-2013 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\nvar fs = require('fs'),\n    http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    stream = require('stream'),\n    stringify = require('./querystring').build,\n    multipart = require('./multipart'),\n    auth = require('./auth'),\n    parsers = require('./parsers'),\n    decoder = require('./decoder'); //////////////////////////////////////////\n// variabilia\n//////////////////////////////////////////\n\n\nvar version = require('../package.json').version,\n    debugging = !!process.env.DEBUG,\n    debug = debugging ? console.log : function () {\n  /* noop */\n};\n\nvar user_agent = 'Needle/' + version;\nuser_agent += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\nvar node_tls_opts = 'agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol'; //////////////////////////////////////////\n// decompressors for gzip/deflate bodies\n//////////////////////////////////////////\n\nvar decompressors = {};\n\ntry {\n  var zlib = require('zlib');\n\n  decompressors['x-deflate'] = zlib.Inflate;\n  decompressors['deflate'] = zlib.Inflate;\n  decompressors['x-gzip'] = zlib.Gunzip;\n  decompressors['gzip'] = zlib.Gunzip;\n} catch (e) {}\n/* zlib not available */\n//////////////////////////////////////////\n// defaults\n//////////////////////////////////////////\n\n\nvar defaults = {\n  accept: '*/*',\n  connection: 'close',\n  user_agent: user_agent,\n  follow: 0,\n  decode_response: true,\n  parse_response: true,\n  timeout: 10000,\n  encoding: 'utf8',\n  boundary: '--------------------NODENEEDLEHTTPCLIENT' //////////////////////////////////////////\n  // the main act\n  //////////////////////////////////////////\n\n};\nvar Needle = {\n  request: function (method, uri, data, options, callback) {\n    var self = this,\n        out = new stream.PassThrough({\n      objectMode: false\n    }),\n        callback = typeof options == 'function' ? options : callback,\n        options = options || {}; // if no 'http' is found on URL, prepend it\n\n    if (uri.indexOf('http') == -1) uri = 'http://' + uri;\n    var config = {\n      base_opts: {},\n      proxy: options.proxy,\n      output: options.output,\n      encoding: options.encoding || (options.multipart ? 'binary' : defaults.encoding),\n      decode_response: options.decode === false ? false : defaults.decode_response,\n      parse_response: options.parse === false ? false : defaults.parse_response,\n      follow: options.follow === true ? 10 : typeof options.follow == 'number' ? options.follow : defaults.follow,\n      timeout: typeof options.timeout == 'number' ? options.timeout : defaults.timeout // if any of node's TLS options are passed, let them be passed to https.request()\n\n    };\n    node_tls_opts.split(' ').forEach(function (key) {\n      if (typeof options[key] != 'undefined') {\n        config.base_opts[key] = options[key];\n        if (typeof options.agent == 'undefined') config.base_opts.agent = false; // otherwise tls options are skipped\n      }\n    });\n    config.headers = {\n      'Accept': options.accept || defaults.accept,\n      'Connection': options.connection || defaults.connection,\n      'User-Agent': options.user_agent || defaults.user_agent\n    };\n    if (options.compressed && typeof zlib != 'undefined') config.headers['Accept-Encoding'] = 'gzip,deflate';\n\n    for (var h in options.headers) config.headers[h] = options.headers[h];\n\n    if (options.username) {\n      if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n        config.credentials = [options.username, options.password];\n      } else {\n        var auth_header = options.proxy ? 'Proxy-Authorization' : 'Authorization';\n        config.headers[auth_header] = auth.basic(options.username, options.password);\n      }\n    }\n\n    if (data) {\n      if (method.toUpperCase() == 'GET') {\n        // build query string and append to URI\n        uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n        post_data = null;\n      } else if (options.multipart) {\n        // build multipart body for request\n        var boundary = options.boundary || defaults.boundary;\n        multipart.build(data, boundary, function (err, body) {\n          if (err) throw err;\n          config.headers['Content-Type'] = 'multipart/form-data; boundary=' + boundary;\n          config.headers['Content-Length'] = body.length;\n          self.send_request(1, method, uri, config, body, out, callback);\n        });\n        return out; // stream\n      } else if (this.is_stream(data) || Buffer.isBuffer(data)) {\n        post_data = data;\n      } else {\n        // string or object data, no multipart.\n        // format data according to content type\n        var post_data = typeof data === 'string' ? data : options.json ? JSON.stringify(data) : stringify(data); // if no content-type was passed, determine if json or not.\n\n        if (!config.headers['Content-Type']) {\n          config.headers['Content-Type'] = options.json ? 'application/json' : 'application/x-www-form-urlencoded';\n        }\n\n        post_data = new Buffer(post_data, config.encoding);\n        config.headers['Content-Length'] = post_data.length; // unless a specific accept header was passed, assume json wants json back.\n\n        if (options.json && config.headers['Accept'] === defaults.accept) config.headers['Accept'] = 'application/json';\n      }\n    }\n\n    return this.send_request(1, method, uri, config, post_data, out, callback);\n  },\n  get_request_opts: function (method, uri, config) {\n    var opts = config.base_opts,\n        proxy = config.proxy,\n        remote = proxy ? url.parse(proxy) : url.parse(uri);\n    opts.protocol = remote.protocol;\n    opts.host = remote.hostname;\n    opts.port = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n    opts.path = proxy ? uri : remote.pathname + (remote.search || '');\n    opts.method = method;\n    opts.headers = config.headers;\n    opts.headers['Host'] = proxy ? url.parse(uri).hostname : remote.hostname;\n    if (opts.port != 80 && opts.port != 443) opts.headers['Host'] += ':' + opts.port;\n    return opts;\n  },\n  get_auth_header: function (header, credentials, request_opts) {\n    var type = header.split(' ')[0],\n        user = credentials[0],\n        pass = credentials[1];\n\n    if (type == 'Digest') {\n      return auth.digest(header, user, pass, request_opts.method, request_opts.path);\n    } else if (type == 'Basic') {\n      return auth.basic(user, pass);\n    }\n  },\n  send_request: function (count, method, uri, config, post_data, out, callback) {\n    var timer,\n        returned = 0,\n        self = this,\n        request_opts = this.get_request_opts(method, uri, config),\n        protocol = request_opts.protocol == 'https:' ? https : http;\n\n    var done = function (err, resp, body) {\n      if (returned++ > 0) return;\n      if (callback) callback(err, resp, body);else out.emit('end', err, resp, body);\n    };\n\n    debug('Making request #' + count, request_opts);\n    var request = protocol.request(request_opts, function (resp) {\n      var headers = resp.headers;\n      debug('Got response', headers);\n      if (timer) clearTimeout(timer); // if redirect code is found, send a GET request to that location if enabled via 'follow' option\n\n      if ([301, 302].indexOf(resp.statusCode) != -1 && headers.location) {\n        if (count <= config.follow) {\n          out.emit('redirect', headers.location);\n          delete config.headers['Content-Length']; // in case the original was a multipart POST request.\n\n          return self.send_request(++count, 'GET', url.resolve(uri, headers.location), config, null, out, callback);\n        } else if (config.follow > 0) {\n          return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n        }\n      } // if authentication is requested and credentials were not passed, resend request if we have user/pass\n\n\n      if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n        if (!config.headers['Authorization']) {\n          // only if authentication hasn't been sent\n          var auth_header = self.get_auth_header(headers['www-authenticate'], config.credentials, request_opts);\n\n          if (auth_header) {\n            config.headers['Authorization'] = auth_header;\n            return self.send_request(count, method, uri, config, post_data, out, callback);\n          }\n        }\n      } // ok so we got a valid (non-redirect & authorized) response. notify the stream guys.\n\n\n      out.emit('headers', headers);\n      var pipeline = [],\n          parsed = false,\n          mime = self.parse_content_type(headers['content-type']),\n          text_response = mime.type && mime.type.indexOf('text/') != -1; // To start, if our body is compressed and we're able to inflate it, do it.\n\n      if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n        pipeline.push(decompressors[headers['content-encoding']]());\n      } // If parse is enabled and we have a parser for it, then go for it.\n\n\n      if (config.parse_response && parsers[mime.type]) {\n        parsed = true;\n        pipeline.push(parsers[mime.type]()); // set objectMode on out stream to improve performance\n\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true; // If we're not parsing, and unless decoding was disabled, we'll try\n        // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n      } else if (text_response && config.decode_response && mime.charset && !mime.charset.match(/utf-?8$/i)) {\n        pipeline.push(decoder(mime.charset));\n      } // And `out` is the stream we finally push the decoded/parsed output to.\n\n\n      pipeline.push(out); // Now release the kraken!\n\n      var tmp = resp;\n\n      while (pipeline.length) {\n        tmp = tmp.pipe(pipeline.shift());\n      } // If the user has requested and output file, pipe the output stream to it.\n      // In stream mode, we will still get the response stream to play with.\n\n\n      if (config.output && resp.statusCode == 200) {\n        resp.pipe(fs.createWriteStream(config.output));\n      } // Only aggregate the full body if a callback was requested.\n\n\n      if (callback) {\n        resp.raw = [];\n        resp.body = [];\n        resp.bytes = 0; // Count the amount of (raw) bytes passed using a PassThrough stream.\n\n        var clean_pipe = new stream.PassThrough();\n        resp.pipe(clean_pipe);\n        clean_pipe.on('readable', function () {\n          var chunk;\n\n          while (chunk = this.read()) {\n            resp.bytes += chunk.length;\n            resp.raw.push(chunk);\n          }\n        }); // Listen on the 'readable' event to aggregate the chunks.\n\n        out.on('readable', function () {\n          var chunk;\n\n          while (chunk = this.read()) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = new Buffer(chunk); // Push all chunks to resp.body. We'll bind them in resp.end().\n\n            resp.body.push(chunk);\n          }\n        }); // And set the .body property once all data is in.\n\n        out.on('end', function () {\n          // we may want access to the raw data, so keep a reference.\n          resp.raw = Buffer.concat(resp.raw); // if parse was successful, we should have an array with one object\n\n          if (resp.body[0] && !Buffer.isBuffer(resp.body[0])) {\n            resp.body = resp.body[0];\n          } else {\n            // we got one or several buffers. string or binary.\n            resp.body = Buffer.concat(resp.body); // if we're here and parsed is true, it means we tried to but it didn't work.\n            // so given that we got a text response, let's stringify it.\n\n            if (text_response || parsed) {\n              resp.body = resp.body.toString();\n            }\n          } // time to call back, junior.\n\n\n          done(null, resp, resp.body);\n        });\n      }\n    }); // end request call\n    // unless timeout was disabled, set a timeout to abort the request\n\n    if (config.timeout > 0) {\n      timer = setTimeout(function () {\n        request.abort();\n      }, config.timeout);\n    }\n\n    request.on('error', function (err) {\n      debug('Request error', err);\n      if (timer) clearTimeout(timer);\n      done(err || new Error('Unknown error when making request.'));\n    });\n\n    if (post_data) {\n      if (this.is_stream(post_data)) {\n        post_data.pipe(request);\n      } else {\n        request.write(post_data, config.encoding);\n        request.end();\n      }\n    } else {\n      request.end();\n    }\n\n    out.request = request;\n    return out;\n  },\n  parse_content_type: function (header) {\n    if (!header || header == '') return {};\n    var charset = 'iso-8859-1',\n        arr = header.split(';');\n\n    try {\n      charset = arr[1].match(/charset=(.+)/)[1];\n    } catch (e) {\n      /* not found */\n    }\n\n    return {\n      type: arr[0],\n      charset: charset\n    };\n  },\n  is_stream: function (obj) {\n    return typeof obj.pipe === 'function';\n  }\n};\nexports.version = version;\n\nexports.defaults = function (obj) {\n  for (var key in obj) {\n    if (defaults[key] && typeof obj[key] != 'undefined') defaults[key] = obj[key];\n  }\n\n  return defaults;\n};\n\n'head get'.split(' ').forEach(function (method) {\n  exports[method] = function (uri, options, callback) {\n    return Needle.request(method, uri, null, options, callback);\n  };\n});\n'post put delete'.split(' ').forEach(function (method) {\n  exports[method] = function (uri, data, options, callback) {\n    return Needle.request(method, uri, data, options, callback);\n  };\n});\n\nexports.request = function (method, uri, data, opts, callback) {\n  return Needle.request(method, uri, data, opts, callback);\n};","map":null,"metadata":{},"sourceType":"script"}