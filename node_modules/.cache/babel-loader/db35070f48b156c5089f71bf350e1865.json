{"ast":null,"code":"//     create-error.js 0.3.1\n//     (c) 2013 Tim Griesser\n//     This source may be freely distributed under the MIT license.\n(function (factory) {\n  \"use strict\"; // A simple utility for subclassing the \"Error\"\n  // object in multiple environments, while maintaining\n  // relevant stack traces, messages, and prototypes.\n\n  factory(function () {\n    var toString = Object.prototype.toString; // Creates an new error type with a \"name\",\n    // and any additional properties that should be set\n    // on the error instance.\n\n    return function () {\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < args.length; ++i) {\n        args[i] = arguments[i];\n      }\n\n      var name = getName(args);\n      var target = getTarget(args);\n      var properties = getProps(args);\n\n      function ErrorCtor(message, obj) {\n        attachProps(this, properties);\n        attachProps(this, obj);\n        this.message = message || this.message;\n\n        if (message instanceof Error) {\n          this.message = message.message;\n          this.stack = message.stack;\n        } else if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, this.constructor);\n        }\n      }\n\n      function Err() {\n        this.constructor = ErrorCtor;\n      }\n\n      Err.prototype = target['prototype'];\n      ErrorCtor.prototype = new Err();\n      ErrorCtor.prototype.name = '' + name || 'CustomError';\n      return ErrorCtor;\n    }; // Just a few helpers to clean up the function above\n    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\n\n    function getName(args) {\n      if (args.length === 0) return '';\n      return isError(args[0]) ? args[1] || '' : args[0];\n    }\n\n    function getTarget(args) {\n      if (args.length === 0) return Error;\n      return isError(args[0]) ? args[0] : Error;\n    }\n\n    function getProps(args) {\n      if (args.length === 0) return null;\n      return isError(args[0]) ? args[2] : args[1];\n    }\n\n    function inheritedKeys(obj) {\n      var ret = [];\n\n      for (var key in obj) {\n        ret.push(key);\n      }\n\n      return ret;\n    } // Right now we're just assuming that a function in the first argument is an error.\n\n\n    function isError(obj) {\n      return typeof obj === \"function\";\n    } // We don't need the full underscore check here, since it should either be\n    // an object-literal, or nothing at all.\n\n\n    function isObject(obj) {\n      return obj && typeof obj === \"object\" && toString.call(obj) === \"[object Object]\";\n    } // Used to attach attributes to the error object in the constructor.\n\n\n    function attachProps(context, target) {\n      if (isObject(target)) {\n        var keys = inheritedKeys(target);\n\n        for (var i = 0, l = keys.length; i < l; ++i) {\n          context[keys[i]] = clone(target[keys[i]]);\n        }\n      }\n    } // Don't need the full-out \"clone\" mechanism here, since if you're\n    // trying to set things other than empty arrays/objects on your\n    // sub-classed `Error` object, you're probably doing it wrong.\n\n\n    function clone(target) {\n      if (target == null || typeof target !== \"object\") return target;\n      var cloned = target.constructor ? target.constructor() : Object.create(null);\n\n      for (var attr in target) {\n        if (target.hasOwnProperty(attr)) {\n          cloned[attr] = target[attr];\n        }\n      }\n\n      return cloned;\n    }\n  }); // Boilerplate UMD definition block...\n})(function (createErrorLib) {\n  if (typeof define === \"function\" && define.amd) {\n    define(createErrorLib);\n  } else if (typeof exports === 'object') {\n    module.exports = createErrorLib();\n  } else {\n    var root = this;\n    var lastcreateError = root.createError;\n    var createError = root.createError = createErrorLib();\n\n    createError.noConflict = function () {\n      root.createError = lastcreateError;\n      return createError;\n    };\n  }\n});","map":null,"metadata":{},"sourceType":"script"}